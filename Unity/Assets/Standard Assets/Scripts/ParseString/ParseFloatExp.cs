//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;


namespace AssemblyCSharpfirstpass
{
	public class ParseFloatExp{
		
		public string _op = "";
		public string _count = "";
		public string _value = "";


		public LinkedList<ParseBoolExp> _childB = new LinkedList<ParseBoolExp> ();
		public LinkedList<ParseStringExp> _childS = new LinkedList<ParseStringExp> ();
		public LinkedList<ParseFloatExp> _childF = new LinkedList<ParseFloatExp> ();
		
			
		public static string[] op = 
		{
			"If",
			"+",
			"--",
			"*",
			"/",
			"Min",
			"Max",
			"Moy",
			"Clamp",
			"HSVtoR",
			"HSVtoG",
			"HSVtoB"

		};

		public ParseFloatExp (){
		}

		public  static ParseFloatExp Make (string s){
			ParseFloatExp item = new ParseFloatExp ();
			
			while (s.StartsWith(" ")){
				s = ParseString.SplitFirst(s, ' ')[1];
			}
			
			string[] strv = ParseString.SplitFirst(s, ',');
			string[] strp = ParseString.SplitFirst(s, ')');
			
			if(strv[0].Length < strp[0].Length){
				item._count = "," + strv[1];
			}
			else{
				item._count = ")" + strp[1];
			}

			string argsAndCount;
			foreach(string opLine in op){
				if (s.StartsWith(opLine.Split(' ')[0])){
					switch(opLine){
						
						// Cas ou le 1er mot est un operateur.
					case "+":
					case "-":
					case "*":
					case "/":
					case "Min":
					case "Max":
					case "Moy":
					case "Clamp":
						item._op = opLine.Split(' ')[0];
						argsAndCount = ParseString.SplitFirst(s, '(')[1];
						while (!argsAndCount.StartsWith(")") ){
							ParseFloatExp child = ParseFloatExp.Make(argsAndCount);
							argsAndCount = child._count;
							item._childF.AddLast(child);
							
							
							
							while (argsAndCount.StartsWith(",")){
								argsAndCount = ParseString.SplitFirst(argsAndCount, ',')[1];
							}
							while (argsAndCount.StartsWith(" ")){
								argsAndCount = ParseString.SplitFirst(argsAndCount, ' ')[1];
							}
							
						}
						item._count = ParseString.SplitFirst(argsAndCount, ')')[1];
						
						break;

					case "HSVtoR":
					case "HSVtoG":
					case "HSVtoB":
						item._op = opLine.Split(' ')[0];
						argsAndCount = ParseString.SplitFirst(s, '(')[1];
						
						ParseStringExp childS = ParseStringExp.Make(argsAndCount);
						argsAndCount = childS._count;
						item._childS.AddLast(childS);
						break;

					case "If":


						item._op = opLine.Split(' ')[0];
						argsAndCount = ParseString.SplitFirst(s, '(')[1];

						ParseBoolExp childB = ParseBoolExp.Make(argsAndCount);
						argsAndCount = childB._count;
						item._childB.AddLast(childB);
						
						
						
						while (argsAndCount.StartsWith(",")){
							argsAndCount = ParseString.SplitFirst(argsAndCount, ',')[1];
						}
						while (argsAndCount.StartsWith(" ")){
							argsAndCount = ParseString.SplitFirst(argsAndCount, ' ')[1];
						}
						
						while (!argsAndCount.StartsWith(")") ){
							ParseFloatExp child = ParseFloatExp.Make(argsAndCount);
							argsAndCount = child._count;
							item._childF.AddLast(child);
							
							
							
							while (argsAndCount.StartsWith(",")){
								argsAndCount = ParseString.SplitFirst(argsAndCount, ',')[1];
							}
							while (argsAndCount.StartsWith(" ")){
								argsAndCount = ParseString.SplitFirst(argsAndCount, ' ')[1];
							}
							
						}
						item._count = ParseString.SplitFirst(argsAndCount, ')')[1];
						
						break;
						
					}
					return item;
				}
			}

			// string : "The string".

			if(strv[0].Length < strp[0].Length){
				item._count = "," + strv[1];
				item._value = strv[0];
			}
			else{
				item._count = ")" + strp[1];
				item._value = strp[0];
			}
			//string[] str = ParseString.SplitFirst(ParseString.SplitFirst(s, '\'')[1], '\'');

					
			return item;

		}

		public float Evaluate(LinkedList<SensorUpdator.KeyValue> LinkKeyValues){
			float res;
			switch (_op){

			case "If":
				if (_childB.First.Value.Evaluate(LinkKeyValues)){
					return _childF.First.Value.Evaluate(LinkKeyValues);
				}
				else{
					return _childF.Last.Value.Evaluate(LinkKeyValues);
				}

			case "Clamp":
				float fVal= _childF.First.Value.Evaluate(LinkKeyValues);
				float fMin= _childF.First.Next.Value.Evaluate(LinkKeyValues);
				float fMax= _childF.First.Next.Next.Value.Evaluate(LinkKeyValues);
				float fstep= _childF.Last.Value.Evaluate(LinkKeyValues);

				if(fMin != fMax){
					int t = (int) Math.Max(0,Math.Min(fstep-1,(fVal - fMin) / (fMax - fMin) * fstep));
					return (float) t;
				}
				else{
					return 0;
				}


			case "+":
				res = 0;
				foreach (ParseFloatExp p in _childF){
					res += p.Evaluate(LinkKeyValues);
				}
				return res;
				
			case "--":
				res = 0;
				return _childF.First.Value.Evaluate(LinkKeyValues) - _childF.Last.Value.Evaluate(LinkKeyValues);

			case "*":
				res = 1;
				foreach (ParseFloatExp p in _childF){
					res *= p.Evaluate(LinkKeyValues);
				}
				return res;
			case "/":
				return _childF.First.Value.Evaluate(LinkKeyValues) / _childF.Last.Value.Evaluate(LinkKeyValues);
				
			case "Min":
				res = _childF.First.Value.Evaluate(LinkKeyValues);
				foreach (ParseFloatExp p in _childF){
					res = Math.Min (res, p.Evaluate(LinkKeyValues));
				}
				return res;

			case "Max":
				res = _childF.First.Value.Evaluate(LinkKeyValues);
				foreach (ParseFloatExp p in _childF){
					res = Math.Max (res, p.Evaluate(LinkKeyValues));
				}
				return res;
				
			case "Moy":
				res = 0;
				int i = 0;
				foreach (ParseFloatExp p in _childF){
					res += p.Evaluate(LinkKeyValues);
					i++;
				}
				if(i == 0){
					return 0f;
				}
				else{
					return res/i;
				}

			case "HSVtoR":
			case "HSVtoG":
			case "HSVtoB":
				float R = 0;
				float G = 0;
				float B = 0;

				string[] HSV = _childS.First.Value.Evaluate(LinkKeyValues).Split(',');
				try{
					float H = float.Parse(HSV[0]);
					float S = float.Parse(HSV[1]) / 100f;
					float V = float.Parse(HSV[2].Replace(")","")) / 100f;
				
					float C = V * S;
					float X = C * (1 - Mathf.Abs(H/60f % 2 -1));
					float m = V - C;
				
					Vector3 rgb = new Vector3 (0,0,0);
				
					if(   0 <= H && H <  60)
						rgb = new Vector3 (C,X,0);
					if(  60 <= H && H < 120)
						rgb = new Vector3 (X,C,0);
					if( 120 <= H && H < 180)
						rgb = new Vector3 (0,C,X);
					if( 180 <= H && H < 240)
						rgb = new Vector3 (0,X,C);
					if( 240 <= H && H < 300)
						rgb = new Vector3 (X,0,C);
					if( 300 <= H && H < 360)
						rgb = new Vector3 (C,0,X);
				
					R = rgb[0]+m;
					G = rgb[1]+m;
					B = rgb[2]+m;
				
					switch (_op){
					case "HSVtoR":
						return R * 255;
					case "HSVtoG":
						return G * 255;
					case "HSVtoB":
						return B * 255;
					default:
						return 0f;
					}
				
					break;
				}
				catch{
					return 127f;
				}
				
			default:
				// Literal TODO
				if(_value == ""){
					return 0;
				}
				if(_value.Contains("#")){
					try{
						return float.Parse(PString.RemplaceSpecialChar(_value,LinkKeyValues));
					}
					catch{
						return 0;
					}
				}
				else{
					try{
					return float.Parse(_value);
					}
					catch{
						return 0;
					}
				}
			}
		}



		public string toString(string tab){
			string res =  tab + _op;
			
			if(_op != ""){

				res += "(\n";
				int i;
				
				i = _childB.Count;
				bool diff1 = false;
				bool diff2 = false;
				foreach( ParseBoolExp b in _childB){
					
					res += b.toString(tab + "\t");
					i--;
					if( i > 0)
						res += ",\n ";
					diff1 = true;
				}
				
				i = _childS.Count;
				foreach( ParseStringExp b in _childS){
					if(diff1){
						res+=",\n";
						diff1 = false;
					}
					res += b.toString(tab + "\t");
					i--;
					if( i > 0)
						res += ",\n ";
					diff2 = true;
				}
				
				i = _childF.Count;
				foreach( ParseFloatExp b in _childF){
					if(diff1 || diff2){
						res+=",\n";
						diff1 = false;
						diff2 = false;
					}
					
					res += b.toString(tab + "\t");
					i--;
					if( i > 0)
						res += ",\n ";
				}
				
				
				res += ")";
			}
			else{
				res += _value;
			}
			return res;
		}

	}
}

